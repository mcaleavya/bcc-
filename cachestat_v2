#!/usr/bin/python
#
#!/usr/bin/python
#
# cachestat     Count cache kernel function calls.
#               For Linux, uses BCC, eBPF. See .c file.
#
# USAGE: cachestat
#
# Taken from funccount by Brendan Gregg , this is a rewrite of cachestat from perf to bcc
# https://github.com/brendangregg/perf-tools/blob/master/fs/cachestat
#
# Copyright (c) 2015 Brendan Gregg.
# Licensed under the Apache License, Version 2.0 (the "License")
#
# 09-Sep-2015   Brendan Gregg   Created this.
# 06-Nov-2015   Allan McAleavy
# 30-Nov-2015   Allan McAleavy  Added Latency Histograms

from __future__ import print_function
from bcc import BPF
from time import sleep, strftime
import argparse
import signal
import re

# signal handler
def signal_ignore(signal, frame):
        print()


# Function to gather data from /proc/meminfo
# return dictionary for quicker lookup of both values

def get_meminfo():

    result = dict()

    for line in open('/proc/meminfo'):
        k = line.split(':',3)
        v = k[1].split()
        result[k[0]] = int (v[0])
    return result


# Set global variables to defaults, I have set total and hits to 1 to avoid divide by zero errors
#
mpa=0
mbd=0
apcl=0
apd=0
total=1
misses=0
hits=0

# args
examples = """examples:
    ./cachestat -i 1        # print every second hit/miss stats
    ./cachestat -L -i 1     # show latency for each function access
    ./cachestat -T -i 1     # include timestamps
"""
parser = argparse.ArgumentParser(
        description="show Linux page cache hit/miss statistics",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=examples)
parser.add_argument("-i", "--interval", default=1,
        help="summary interval, seconds")
parser.add_argument("-T", "--timestamp", action="store_true",
        help="include timestamp on output")
parser.add_argument("-L", "--latency", action="store_true",
        help="include latency historgrams on output experimental")
args = parser.parse_args()


# load BPF program
bpf_text = """

#include <uapi/linux/ptrace.h>
struct key_t {
        u64 ip;
};

typedef struct ip_key {
        u64 ip;
        u64 slot;
} ip_key_t;

BPF_HASH(counts, struct key_t);
BPF_HASH(start, u32);
BPF_HASH(ipaddr, u32);
BPF_HISTOGRAM(dist, ip_key_t);


int trace_start(struct pt_regs *ctx) {
        struct key_t key = {};
        u64 zero = 0, *val;
        u32 pid;
        u64 ts , ip;

        key.ip = ctx->ip;
        ip = ctx->ip;
        val = counts.lookup_or_init(&key, &zero);  // update counter
        pid = bpf_get_current_pid_tgid();  // get pid for updates to histogram
        ts = bpf_ktime_get_ns();
        start.update(&pid,&ts); // update start time
        ipaddr.update(&pid,&ip); // update histogram
        (*val)++;
        return 0;
}


int trace_end(struct pt_regs *ctx) {
        u32 pid;
        u64 *tsp, delta;
        u64 ip , *ipp;

        pid = bpf_get_current_pid_tgid();
        tsp = start.lookup(&pid);

        if (tsp == 0) {
                return 0;
        }

        delta = bpf_ktime_get_ns() - *tsp;
        start.delete(&pid);  // end timer
        ipp = ipaddr.lookup(&pid);
        if (ipp)
         {
          ip = *ipp;
          dist.increment((ip_key_t){ip, bpf_log2l(delta / 1000)});
          ipaddr.delete(&pid);
         }

        return 0;
}

"""
b = BPF(text=bpf_text)
b.attach_kprobe(event="add_to_page_cache_lru", fn_name="trace_start")
b.attach_kretprobe(event="add_to_page_cache_lru", fn_name="trace_end")
b.attach_kprobe(event="mark_page_accessed", fn_name="trace_start")
b.attach_kretprobe(event="mark_page_accessed", fn_name="trace_end")
b.attach_kprobe(event="account_page_dirtied", fn_name="trace_start")
b.attach_kretprobe(event="account_page_dirtied", fn_name="trace_end")
b.attach_kprobe(event="mark_buffer_dirty", fn_name="trace_start")
b.attach_kretprobe(event="mark_buffer_dirty", fn_name="trace_end")

# header
if args.latency:
    print("Latency Histogram for Page Cache Function Access")
elif args.timestamp:
    print("%-8s %8s %8s %8s %8s %12s %10s" % ("TIME","HITS","MISSES","DIRTIES","RATIO","BUFFERS_MB","CACHED_MB"))
elif not args.latency or not args.timestamp:
    print("%8s %8s %8s %8s %12s %10s" % ("HITS","MISSES","DIRTIES","RATIO","BUFFERS_MB","CACHED_MB"))

exiting=0 if args.interval else 1

while (1):
        try:
                sleep(int(args.interval))
        except KeyboardInterrupt:
                exiting=1
                # as cleanup can take many seconds, trap Ctrl-C:
                signal.signal(signal.SIGINT, signal_ignore)



        counts = b.get_table("counts")
        for k, v in sorted(counts.items(), key=lambda counts: counts[1].value):

                if re.match ('mark_page_accessed',b.ksym(k.ip)) is not None:
                   mpa=v.value
                   if mpa < 0 : mpa = 0

                if re.match('mark_buffer_dirty',b.ksym(k.ip)) is not None:
                   mbd=v.value
                   if mbd < 0 : mdb = 0

                if re.match('add_to_page_cache_lru',b.ksym(k.ip)) is not None:
                   apcl=v.value
                   if apcl < 0 : apcl = 0

                if re.match('account_page_dirtied',b.ksym(k.ip)) is not None:
                   apd=v.value
                   if apd < 0 : apd = 0

                total = mpa - mbd
                misses = apcl - apd

                if misses < 0:
                    misses =  0

        counts.clear()
        # Work out hits and ratio
        hits = total - misses
        ratio = 100 * hits / total

        # Get memory info
        mem = get_meminfo()
        cached = int(mem["Cached"]) /1024
        buffer = int(mem["Buffers"]) /1024

        if args.latency:
                dist = b.get_table("dist");
                dist.print_log2_hist("usecs", "Function", BPF.ksym)
                dist.clear()
        elif args.timestamp:
                print("%-8s %8d %8d %8d %7.1f%% %12.0f %10.0f" % (strftime("%H:%M:%S"),hits,misses,mbd,ratio,buffer,cached))
        elif not args.latency or not args.timestamp:
                print("%8d %8d %8d %7.1f%% %12.0f %10.0f"% (hits,misses,mbd,ratio,buffer,cached))

        mbd=0
        apcl=0
        apd=0
        total=1
        misses=0
        hits=1
        cached=0
        buffer=0


        if exiting:
                print("Detaching...")
                exit()

