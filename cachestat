#!/usr/bin/python


# cachestat     Count cache kernel function calls.
#               For Linux, uses BCC, eBPF. See .c file.
#
# USAGE: cachestat
# Taken from funccount by Brendan Gregg
# This is a rewrite of cachestat from perf to bcc
# https://github.com/brendangregg/perf-tools/blob/master/fs/cachestat
#
# Copyright (c) 2015 Brendan Gregg.
# Licensed under the Apache License, Version 2.0 (the "License")
#
# 09-Sep-2015   Brendan Gregg   Created this.
# 06-Nov-2015   Allan McAleavy
# 30-Nov-2015   Allan McAleavy  Added Latency Histograms
# 13-Jan-2016   Allan McAleavy  run pep8 against program

from __future__ import print_function
from bcc import BPF
from time import sleep, strftime
import argparse
import signal
import re

# signal handler


def signal_ignore(signal, frame):
        print()


# Function to gather data from /proc/meminfo
# return dictionary for quicker lookup of both values

def get_meminfo():

    result = dict()

    for line in open('/proc/meminfo'):
        k = line.split(':', 3)
        v = k[1].split()
        result[k[0]] = int(v[0])
    return result

# set global variables

rtaccess = 0
wtaccess = 0
mpa = 0
mbd = 0
apcl = 0
apd = 0
access = 0
misses = 0
rhits = 0
whits = 0
debug = 0

# args
examples = """examples:
    ./cachestat -i 1        # print every second hit/miss stats
    ./cachestat -L -i 1     # show latency for each function access
    ./cachestat -T -i 1     # include timestamps
"""
parser = argparse.ArgumentParser(
        description="show Linux page cache hit/miss statistics",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=examples)
parser.add_argument("-i", "--interval", default=1,
        help="summary interval, seconds")
parser.add_argument("-T", "--timestamp", action="store_true",
        help="include timestamp on output")
parser.add_argument("-L", "--latency", action="store_true",
        help="include latency historgrams on output experimental")
args = parser.parse_args()


# load BPF program
bpf_text = """

#include <uapi/linux/ptrace.h>
struct key_t {
        u64 ip;
};

typedef struct ip_key {
        u64 ip;
        u64 slot;
} ip_key_t;

BPF_HASH(counts, struct key_t);
BPF_HASH(start, u32);
BPF_HASH(ipaddr, u32);
BPF_HISTOGRAM(dist, ip_key_t);


int trace_start(struct pt_regs *ctx) {
        struct key_t key = {};
        u64 zero = 0, *val;
        u32 pid;
        u64 ts , ip;

        key.ip = ctx->ip;
        ip = ctx->ip;
        val = counts.lookup_or_init(&key, &zero);  // update counter
        pid = bpf_get_current_pid_tgid();  // get pid for updates to histogram
        ts = bpf_ktime_get_ns();
        start.update(&pid,&ts); // update start time
        ipaddr.update(&pid,&ip); // update histogram
        (*val)++;
        return 0;
}


int trace_end(struct pt_regs *ctx) {
        u32 pid;
        u64 *tsp, delta;
        u64 ip , *ipp;

        pid = bpf_get_current_pid_tgid();
        tsp = start.lookup(&pid);

        if (tsp == 0) {
                return 0;
        }

        delta = bpf_ktime_get_ns() - *tsp;
        start.delete(&pid);  // end timer
        ipp = ipaddr.lookup(&pid);
        if (ipp)
         {
          ip = *ipp;
          dist.increment((ip_key_t){ip, bpf_log2l(delta / 1000)});
          ipaddr.delete(&pid);
         }

        return 0;
}

"""
b = BPF(text=bpf_text)
b.attach_kprobe(event="add_to_page_cache_lru", fn_name="trace_start")
b.attach_kretprobe(event="add_to_page_cache_lru", fn_name="trace_end")
b.attach_kprobe(event="mark_page_accessed", fn_name="trace_start")
b.attach_kretprobe(event="mark_page_accessed", fn_name="trace_end")
b.attach_kprobe(event="account_page_dirtied", fn_name="trace_start")
b.attach_kretprobe(event="account_page_dirtied", fn_name="trace_end")
b.attach_kprobe(event="mark_buffer_dirty", fn_name="trace_start")
b.attach_kretprobe(event="mark_buffer_dirty", fn_name="trace_end")

# header
if args.latency:
    print("Latency Histogram for Page Cache Function Access")
elif args.timestamp:
    print("%-8s %8s %8s %8s %8s %8s %12s %10s" % ("TIME", "HITS", "MISSES", "DIRTIES", "READ HIT%", "WRITE HIT%", "BUFFERS_MB", "CACHED_MB"))

elif not args.latency or not args.timestamp:
    print("%8s %8s %8s %8s %8s %12s %10s" % ("HITS", "MISSES", "DIRTIES", "READ HIT%", "WRITE HIT%", "BUFFERS_MB", "CACHED_MB"))

exiting = 0 if args.interval else 1

while (1):
        try:
                sleep(int(args.interval))
        except KeyboardInterrupt:
                exiting = 1
                # as cleanup can take many seconds, trap Ctrl-C:
                signal.signal(signal.SIGINT, signal_ignore)

        counts = b.get_table("counts")
        for k, v in sorted(counts.items(), key=lambda counts: counts[1].value):

                if re.match('mark_page_accessed', b.ksym(k.ip)) is not None:
                    mpa = v.value
                    if mpa < 0:
                        mpa = 0

                if re.match('mark_buffer_dirty', b.ksym(k.ip)) is not None:
                    mbd = v.value
                    if mbd < 0:
                        mbd = 0

                if re.match('add_to_page_cache_lru', b.ksym(k.ip)) is not None:
                    apcl = v.value
                    if apcl < 0:
                        apcl = 0

                if re.match('account_page_dirtied', b.ksym(k.ip)) is not None:
                    apd = v.value
                    if apd < 0:
                        apd = 0

# access = total of the cache access including reads(mpa) and writes(mbd)
# misses = total of add to lru which we do when we write(mbd)
# and also the mark the page dirty(same as mbd)

                access = (mpa + mbd)
                misses = (apcl + apd)

                # rtaccess is the read hit % during the sample period.
                # wtaccess is the write hit % during the smaple period.

                if mpa > 0:
                    rtaccess = float(mpa) / (access + misses)
                if apcl > 0:
                    wtaccess = float(apcl) / (access + misses)

                if wtaccess != 0:
                    whits = 100 * wtaccess
                if rtaccess != 0:
                    rhits = 100 * rtaccess

        if debug:
            print("%d %d %d %d %d %d %f %f %d %d\n" % (mpa, mbd, apcl, apd, access, misses, rtaccess, wtaccess, rhits, whits))

        counts.clear()

        # Get memory info
        mem = get_meminfo()
        cached = int(mem["Cached"]) / 1024
        buffer = int(mem["Buffers"]) / 1024

        if args.latency:
                dist = b.get_table("dist")
                dist.print_log2_hist("usecs", "Function", BPF.ksym)
                dist.clear()

        elif args.timestamp:
            print("%-8s %8d %8d %8d %7.1f%% %7.1f%% %12.0f %10.0f" % (strftime("%H:%M:%S"), access, misses, mbd, rhits, whits, buffer, cached))

        elif not args.latency or not args.timestamp:
            print("%8d %8d %8d %7.1f%% %7.1f%% %12.0f %10.0f" % (access, misses, mbd, rhits, whits, buffer, cached))

        mpa = 0
        mbd = 0
        apcl = 0
        apd = 0
        access = 0
        misses = 0
        rhits = 0
        cached = 0
        buffer = 0
        whits = 0
        rtaccess = 0
        wtaccess = 0

        if exiting:
                print("Detaching...")
                exit()
